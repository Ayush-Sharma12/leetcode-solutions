class Solution {
    public int maxCollectedFruits(int[][] fruits) {

           int n = fruits.length; 
           int totalFruits = 0;  
           for(int i = 0;  i<n; i++) { // first diagonal move for child 1
                 totalFruits += fruits[i][i];
                 fruits[i][i] = -1;
           }  
        

           int[][] mem = new int[n][n];   
           for(int[] m : mem) {
               Arrays.fill(m, -1);
           }   
          
           int[][] dir2 = {{1, -1}, {1, 0}, {1, 1}};
           int child2 = f(fruits, dir2, mem,   n,  0, n-1, n-1);  
             
           for(int[] m : mem) { // refresh the memo table
               Arrays.fill(m, -1);
           }   
           int[][] dir3 = {{-1, 1}, {0, 1}, {1, 1}};
           int child3 = f(fruits, dir3, mem,  n,  n-1, 0, n-1);

           return totalFruits + child2 + child3;

    }

    private int f(int[][] fruits, int[][] dir, int[][] mem,  int n,  int i, int j, int move) {
           if(i < 0 || i>= n || j<0 || j>=n) {
                   return Integer.MIN_VALUE;
           }

           if(move == 0) {
               if(i == n-1 && j == n-1) {
                    return 0;
               }

               return Integer.MIN_VALUE;
           } 

           if(fruits[i][j] == -1) {
              return Integer.MIN_VALUE;
           }  

           if(mem[i][j] != -1) {
               return mem[i][j];
           }

          
           
           int max = -1; 
           for(int[] d : dir) {
               int i_ = i + d[0];
               int j_ = j + d[1];
                
               int val = f(fruits, dir, mem, n, i_, j_, move-1); 
               if(val != Integer.MIN_VALUE) {
                     max = Math.max(max, val);  
               }
           }  

           return mem[i][j] = (max == -1 ? Integer.MIN_VALUE : fruits[i][j] + max);
    }
}